---
snip: 20
title: ERC-20 代币的法定支付者
description: 本 SNIP 提出了一个法定支付者的设计，用于 ERC-20 代币
author: Ilia Volokh <iliav@starkware.co>, Leonardo Lerer <leo@starkware.co>
discussions-to: 
status: Review
type: Standards Track
category: Core
created: 2024-09-15
---

## 简要总结
我们提出了一种法定支付者的设计，利用了版本 3 的 INVOKE 交易中的 `paymaster` 字段。该设计允许任何人部署支付者合约，从而将代币交换抽象化，用户无需直接处理。其范围仅限于 ERC-20 合约，并不提供完全的费用抽象（例如，使用 NFT 或其他资产支付交易费用）。

简而言之，用户发送 v3 交易，并在 `paymaster` 字段中指定三项数据：
1. 支付者合约地址
2. ERC-20 代币合约地址
3. 上述代币与 STRK 之间的最大允许汇率。具体而言，最大汇率 `r` 意味着用户愿意为一个 STRK 支付最多 `r` 个代币。
目标支付者合约将接收用户的资金（以其选择的 ERC-20 代币计）并以不超过 `r` 的汇率向排序者支付交易费用（以 STRK 计）。经济计算和汇率选择由每个支付者合约自行决定。

该提案不涉及声誉系统、法定预言机/AMM 或其他部署支付者合约的资本成本。

## 动机

Starknet 交易费用市场将作用于 v3 交易，其费用以本地费用代币 STRK 计（另见 [SNIP-16](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-16.md)）。然而，用户可能希望使用其他代币支付交易费用。支付者是提供此类功能的机制、产品和/或服务的统称。

广义上讲，支付者可以是应用级的或法定/协议级的。后者指的是在协议级别被认可的支付者机制，例如通过交易版本 3 中的 `paymaster` 字段。前者是后者的补充，例如仅依赖外部执行的架构（见 [SNIP-9](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-9.md)）。

我们认为用户在不拥有 STRK 的情况下在 Starknet 上进行交易的能力是一个重要特性。此外，我们支持法定化此类机制，以避免这些用户对标准交易流程外部额外服务的严格依赖。因此，我们提出了这一法定支付者的设计提案。

## 提案

我们从 [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) 中获得灵感，尽管我们采取了稍微不同的路线。

### 定义

我们将一个合约称为 _支付者_，如果它具有 `__validate_paymaster__` 入口点。对于 `__validate_paymaster__` 不需要任何计算限制，因为用户将为其失败付费 - 这一点将在后面详细解释。

一个示例 `__validate_paymaster__` 将从某些选定的预言机或 AMM 中读取汇率，并检查用户指定的汇率是否足够宽松，例如 `1.05 × oracle_rate ≤ r`。

一个 _支付者交易_ 是指具有非空 _paymaster 字段_ 的交易。有效的支付者交易在 `paymaster` 字段中指定三项连接的数据：
1. 支付者合约地址
2. ERC-20 代币合约地址
3. 上述代币与 STRK 之间的最大允许汇率。具体而言，最大汇率 `r` 意味着用户愿意为一个 STRK 支付最多 `r` 个代币。

### 流程

我们现在概述排序者处理支付者交易的步骤。为简单起见，初始流程将以用户的最大汇率 `r` 收费；以折扣率收费的优化将推迟到下一节。

#### 内存池

用户可以提交不切实际的低汇率；这些应被解释为对其指定支付代币的高估。夸大的声明应被拒绝。然而，我们希望避免在协议级别定义“合理汇率”。为此，每个排序者客户端通过字典本地定义合理汇率：`TOKEN → min_STRK/TOKEN_rate`。（该比率遵循交易惯例：它是一个 STRK 的价格，以 TOKEN 为单位。）该字典可以是静态的或通过某些预言机馈送动态更新。排序者还可以选择仅服务于某些选定的支付者合约白名单。

完整节点可以维护此类配置，或不加区分地传播支付者交易，而不查看 `paymaster` 字段。在前一种情况下，每个完整节点根据其本地配置从 P2P 网络中过滤一些支付者交易。如果大多数节点的配置与排序者相似，这将通过减少网络上无效交易的流量来提供服务，基本上保护排序者的内存池。另一方面，如果完整节点配置得过于保守，它们可能会过滤掉排序者愿意处理的支付者交易。在后一种情况下，如果完整节点不维护任何配置，所有无效交易将需要被某个排序者拒绝进入其内存池。

现在流程如下：

1. 语法检查（交易格式正确）。
2. 用户提交的汇率应至少为客户端本地配置的汇率。`min_STRK/TOKEN_rate ≤ r`
3. 余额检查：
    * 用户代币余额应覆盖其出价，考虑其指定的最大汇率 `balance(user) ≥ max_amount × r(base_price(current_block)+tip)`。
    * 支付者 STRK 余额应覆盖用户出价 `balance(paymaster) ≥ max_amount × (base_price(current_block)+tip)`。

#### 区块构建者

支付者合约仅应由信任其代码的用户使用。这些用户了解支付者的汇率政策，因此知道他们应提交哪些汇率以通过，以及哪些汇率过于节俭可能导致 `__validate_paymaster__` 失败。因此，我们认为“指责”用户因 `__validate_paymaster__` 失败是合理的，并因此向他们收费。现在出现一个问题场景：用户可能持有零 STRK，而支付者拒绝请求以覆盖其交易费用。在这种情况下，我们允许排序者直接以用户指定的代币收取交易费用。

在上述简单示例中，`__validate_paymaster__` 仅在 `min_STRK/TOKEN_rate ≤ r ≤ 1.05 × oracle_rate` 时在区块构建期间失败，这意味着用户的汇率足够高以进入客户端的内存池，但对支付者来说过低。

现在流程如下：

1. 余额检查：
    * 用户代币余额应覆盖其出价，考虑其指定的最大汇率 `balance(user) ≥ max_amount × r(base_price(current_block)+tip)`。如果成功，继续；否则，拒绝。
    * 支付者 STRK 余额应覆盖用户出价 `balance(paymaster) ≥ max_amount × (base_price(current_block)+tip)`。如果成功，继续；否则，拒绝。
2. 运行账户 `__validate__`。如果成功，继续；否则，拒绝。
3. 运行支付者 `__validate_paymaster__`。如果成功，继续；否则，回滚并跳过下面的费用调用。
4. 运行账户 `__execute__`。如果成功，继续；否则，回滚并跳过下面的费用调用。
5. 费用调用：
    * 如果失败发生在 `__validate_paymaster__`，用户以指定的费用代币支付排序者：
        * 销毁 `used_amount × r × base_price`。
        * 转账 `used_amount × r × tip`。
    * 如果失败发生在后面：
        1. 支付者向排序者支付交易费用：
            * 销毁 `used_amount × base_price`。
            * 转账 `used_amount × tip`。
        2. 用户支付支付者：转账 `used_amount × r × (base_price(current_block)+tip)`。
    * 如果在费用调用期间发生失败，回滚所有状态更改并直接返回（跳过 `__validate_paymaster__` 和 `execute`）。这确保用户和支付者在两个余额检查中都有足够的余额。
### 优化：折扣支付者费率

在上述流程中，支付者始终以用户的最高费率 `r` 收费。这鼓励了对费率的战略“竞标”。允许支付者合约以低于用户提交的最高费率的较小费率收费是更好的。为此，我们允许 `__validate_paymaster__` 输出一个满足 `charging_rate ≤ r` 的 `charging_rate`。如果 `__validate_paymaster__` 执行成功，费用调用将继续进行，用户的最高费率将被支付者的 `charging_rate` 替代。

### SDK 和钱包集成

为了实现真正无缝的体验，钱包应：
1. 与支付者集成以支持支付者交易。
2. 与预言机集成以建议准确的最高费率。
3. 将上述内容集成到其用户界面中，以便最终用户可以选择支付代币并接收建议的竞标（包括费率）以便一键确认。

在后台，SDK 还应支持发送支付者交易。

## 理由

我们认为上述设计促进了简单且安全的支付者合约，提供了让用户使用任意 ERC-20 代币支付交易费用的所需功能。

## 缺点

1. 设置其最高费率在 `min_STRK/TOKEN_rate ≤ r ≤ min_STRK/TOKEN_rate_accepted_by_paymaster` 范围内的用户将经历 `__validate_paymaster__` 的回退并为回退支付费用。如上所述，通过提交高费率可以轻松解决此问题，特别是对于以折扣费率收费的支付者。

2. 提议设计的功能仅限于 ERC-20 代币，并未实现任何更高的费用抽象目标。当然，与完全没有功能相比，这并不是一个缺点。

3. 排序者需要主动（重新）配置其设置以支持新代币和/或支付者合约。因此，如果某些代币/合约的采用率较低，相关的支付者交易将仅偶尔包含在区块中。

4. 与任何协议的添加一样，支付者流程是 Starknet 的另一个复杂性。我们认为其好处是值得的，并希望缺点仍然是理论上的。

5. 本提案不支持作为支付者的 AMM：费用调用逻辑是固定的。

## 向后兼容性

本提案向后兼容，因为它仅提出了具有非空 `paymaster` 字段的交易的语义，该字段此前未被使用。

## 安全考虑

如果排序者本地配置的最低费率过低，则在 `__validate_paymaster__` 失败的情况下，它可能面临被低估支付的风险。

## 版权

通过 [MIT](../LICENSE) 放弃版权及相关权利。